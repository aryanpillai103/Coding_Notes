
## A. Brute Force Solution

```cpp
void Rotatetoright(int arr[], int n, int k)
{
  if (n == 0) //if n is equal to zero, simply return 
    return;
  k = k % n; //for rotation of array
  if (k > n) //if k id greater than n, then simply return 
    return;
  int temp[k]; //declare a temp array of size k 
  for (int i = n - k; i < n; i++) //shift last k elements to the temp array
  {
    temp[i - n + k] = arr[i];
  }
  for (int i = n - k - 1; i >= 0; i--)//shift n-k elements from the beginning by k positions to the right 
  {
    arr[i + k] = arr[i];
  }
  for (int i = 0; i < k; i++) //iterate fron 0 to k
  {
    arr[i] = temp[i]; //replace arr elemnts with temp
  }
}
```

```cpp
void Rotatetoleft(int arr[], int n, int k)
{
  if (n == 0) //if n is equal to 0, simply return
    return;
  k = k % n;//for rotation of the array
  if (k > n) // if k i greater than n, then simply return 
    return;
  int temp[k];// declare temp array of size k
  for (int i = 0; i < k; i++) // iterate from 0 to k
  {
    temp[i] = arr[i]; //copy first k elements into the temp array
  }
  for (int i = 0; i < n - k; i++) //iterate from 0 to n-k
  {
    arr[i] = arr[i + k]; // shift n-k elements from the beginning by k positions to the right
  }
  for (int i = n - k; i < n; i++) // iterate from n-k to n
  {
    arr[i] = temp[i - n + k]; //copy the element from main array from the temp array
  }
}
```


Tme Complexity: O(n) (as we are traversing 3n times which is equivalent to n) <br>
Space Complexity: O(k) since k array elements needs to be stored in temp array.

## B.Using Reverse Algorithm

```cpp
void Reverse(int arr[], int start, int end)
{
  while (start <= end)
  {
    int temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
    start++;
    end--;
  }
}
```




